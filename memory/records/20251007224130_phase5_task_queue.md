# Phase 5 — Optimization Task Queue

## Task 1: Capture Performance Baseline
- **Lifecycle**: Phase 5 Optimization — Step 1 (Profiling Setup)
- **Mindset**: Tasker → Integrator (measurement-focused)
- **Workspace**: `tools/`, `workspaces/Describing_Simulation_0/src/core/`
- **Guardrails**:
  - `instruction_documents/Describing_Simulation_0_schedule_of_work.md` — Phase 5 optimization expectations (runtime & memory inspection).
  - `instruction_documents/Describing_Simulation_0_codifying_simulations.md` — Core loop and messaging architecture (Frame publishing, Bus usage).
  - Latest verification artifacts in `verifications/` to understand current throughput.
- **Objective**: Establish a repeatable profiling harness that exercises the simulation loop for hundreds of ticks, capturing wall-clock timing and memory high-water marks without modifying production logic.
- **Definition of Done**:
  1. Add a script under `tools/` (e.g., `benchmark_simulation.js`) that boots the compiled workspace, injects the temperature control system, and advances at least 500 ticks while capturing duration and RSS deltas via `process.hrtime.bigint()` and `process.memoryUsage()`.
  2. Persist the baseline metrics to `verifications/` (timestamped JSON or log) and summarize key figures in a new record within `memory/records/`.
  3. Run `npm --prefix workspaces/Describing_Simulation_0 test` and `./tools/run_integration.sh` to confirm the harness does not regress existing behavior.

## Task 2: Optimize Bus Publish Path
- **Lifecycle**: Phase 5 Optimization — Step 2 (Hot-path Tightening)
- **Mindset**: Implementer
- **Workspace**: `workspaces/Describing_Simulation_0/src/core/messaging/Bus.ts`, `workspaces/Describing_Simulation_0/src/core/messaging/__tests__/`
- **Guardrails**:
  - `instruction_documents/Describing_Simulation_0_codifying_simulations.md` — Messaging bus requirements.
  - Profiling output from Task 1 pinpointing publish overhead.
  - `instruction_documents/Describing_Simulation_0_implementation_guidelines.md` — TDD discipline for refactors.
- **Objective**: Remove the per-publish array spread (`[...subscribers]`) to cut allocation churn while preserving safe iteration when subscribers unsubscribe or re-subscribe during callbacks.
- **Definition of Done**:
  1. Refactor `Bus.publish` to iterate without cloning while defending against subscription mutations (e.g., tolerate unsubscribes during dispatch).
  2. Extend tests to cover subscriber removal within a callback and ensure order guarantees remain (`Bus.test.ts` should assert no skipped deliveries).
  3. Execute workspace unit tests and integration script, updating the verification log with results tied to the optimization.

## Task 3: Reduce Frame Snapshot Allocations
- **Lifecycle**: Phase 5 Optimization — Step 3 (Simulation Loop Efficiency)
- **Mindset**: Implementer
- **Workspace**: `workspaces/Describing_Simulation_0/src/core/simplayer/IOPlayer.ts`, `workspaces/Describing_Simulation_0/src/core/components/ComponentManager.ts`, relevant tests.
- **Guardrails**:
  - `instruction_documents/Describing_Simulation_0_codifying_simulations.md` — Frame construction expectations for outbound messaging.
  - Baseline metrics from Task 1 to target allocation hotspots (tick snapshot creation).
  - Existing unit coverage (`IOPlayer` and component manager specs) to guide regression checks.
- **Objective**: Trim per-tick object churn when creating frame snapshots (e.g., reuse accumulator objects or expose a leaner component snapshot helper) without leaking mutable references to subscribers.
- **Definition of Done**:
  1. Implement an approach that avoids rebuilding intermediate arrays/maps on every tick (consider introducing a `ComponentManager.snapshot(entity)` helper or reusing buffers in `IOPlayer`).
  2. Update or add tests ensuring frame payloads remain correct and immutable from the caller’s perspective; include a regression test that mutating the published frame does not affect subsequent ticks.
  3. Validate changes via workspace tests and integration script, capturing before/after notes referencing Task 1 metrics.

## Task 4: Re-benchmark and Document Gains
- **Lifecycle**: Phase 5 Optimization — Step 4 (Validation & Documentation)
- **Mindset**: Integrator
- **Workspace**: `tools/`, `verifications/`, `memory/records/`
- **Guardrails**:
  - `instruction_documents/Describing_Simulation_0_schedule_of_work.md` — Requirement to validate optimizations with integration tests.
  - Profiling harness from Task 1.
  - Verification logging conventions in `verifications/README.md`.
- **Objective**: Re-run the profiling harness and integration workflows post-optimization, quantifying improvements and ensuring no behavioral regressions.
- **Definition of Done**:
  1. Execute the benchmark script, unit tests, `./checks.sh`, and `./tools/run_integration.sh`, recording output artifacts alongside baseline data.
  2. Append a comparative summary (baseline vs improved throughput and memory) to `verifications/` and a dedicated memory record outlining residual risks or further optimization ideas.
  3. Confirm README or information routes do not require updates after performance tuning; note explicitly if no documentation changes are necessary.
